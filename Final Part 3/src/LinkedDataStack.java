import java.util.EmptyStackException;import java.util.Iterator;import java.util.NoSuchElementException;/**   An implementation of the Stack data type using linked data   @author Eli Zupke   @version 1.0 */public class LinkedDataStack<T> implements StackInterface<T>{	// This is a reference to the node at the top of the stack	Node<T> top;	public LinkedDataStack() {		top = null;	}	public void push(T newEntry) {		Node<T> newTop = new Node<T>(newEntry);		newTop.setNextNode(top);		top = newTop;	}	/** Removes and returns this stack's top entry.       @return  The object at the top of the stack.        @throws  EmptyStackException if the stack is empty before the operation. */	public T pop() {		if (isEmpty()) {			throw new EmptyStackException();		} else {			// We get the data of the top node to be returned later and move the top pointer down a level in the stack.			T poppedData = top.getData();			top = top.getNextNode();			return poppedData;		}	}	/** Retrieves this stack's top entry.       @return  The object at the top of the stack.       @throws  EmptyStackException if the stack is empty. */	public T peek() {		if (isEmpty()) {			throw new EmptyStackException();		} else {			return top.getData();		}	}	/** Detects whether this stack is empty.       @return  True if the stack is empty. */	public boolean isEmpty() {		return (top == null);	}	/** Removes all entries from this stack. */	public void clear() {		// Dereferences the top element of the stack, which will ultimately remove the entire stack from memory.		top = null;	}	/**	 * Returns an iterator that iterates over the stack's values. Removal is not supported.	 * (This functionality was added during the final!)	 * @return An iterator of type T that iterates over the stack's values	 */	public Iterator<T> getIterator() {		return new LinkedDataStackIterator();	}		private class LinkedDataStackIterator implements Iterator<T> {		// The node we just gave		Node<T> prevNode = null;		// The node we are about to give		Node<T> curNode = top;		@Override		public boolean hasNext() {			return curNode != null;		}		@Override		public T next() {			if (!hasNext()) {				throw new NoSuchElementException();			}			prevNode = curNode;			curNode = curNode.getNextNode();			return prevNode.getData();		}		@Override		public void remove() {			throw new UnsupportedOperationException();		}		}}