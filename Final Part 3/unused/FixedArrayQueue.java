import java.util.Iterator;import java.util.NoSuchElementException;/**   A Queue data structure implemented via fixed-size arrays.       @author Eli Zupke   @version 1.0 */public class FixedArrayQueue<T> implements QueueInterface<T>{	private T[] queue;	private static final int DEFAULT_CAPACITY = 10;		// This is the position of the front item in the queue.	private int frontEntry;		// This is the position of the last item in the queue.	private int backEntry;		private boolean isEmpty;		public FixedArrayQueue() {		this(DEFAULT_CAPACITY);	}		public FixedArrayQueue(int capacity) {		        @SuppressWarnings("unchecked")        T[] tempArray = (T[])new Object[capacity]; // Unchecked cast		queue = tempArray;		frontEntry = 0;		backEntry = 0;		isEmpty = true;	}	/** Adds a new entry to the back of this queue.      @param newEntry  An object to be added. */	public void enqueue(T newEntry) {		if ((backEntry + 1) % queue.length == frontEntry && !isEmpty()) {			throw new IllegalStateException("Queue Full!");		} else {			// We should only adjust the position of the back pointer if we are nut full.			if (!isEmpty()) {				// Choose the spot for the new back entry to go, wrapping back to the start if necessary. 				backEntry = (backEntry + 1) % queue.length;				}			queue[backEntry] = newEntry;			isEmpty = false;			//System.out.println("Front: " + frontEntry + ", Back: " + backEntry);		}	}	/** Removes and returns the entry at the front of this queue.      @return  The object at the front of the queue.       @throws  EmptyQueueException if the queue is empty before the operation. */	public T dequeue() {		if (isEmpty()) {			throw new EmptyQueueException();		} else {						// Set the isEmpty flag if this is the last element in the queue.			if (frontEntry == backEntry) {				isEmpty = true;			}						// Get the entry we will return			T dequeuedEntry = queue[frontEntry];						// Remove the dequeued entry from the queue			queue[frontEntry] = null;						// Move the front entry forward one, wrapping back to the start if needed.			frontEntry = (frontEntry + 1) % queue.length;			// If we emptied the queue, we should reset these pointers to prevent problems.			if (isEmpty) {				frontEntry = 0;				backEntry = 0;			}						return dequeuedEntry;		}	}	/**  Retrieves the entry at the front of this queue.      @return  The object at the front of the queue.      @throws  EmptyQueueException if the queue is empty. */	public T getFront() {		if (isEmpty()) {			throw new EmptyQueueException();		} else {			return queue[frontEntry];		}	}	/** Detects whether this queue is empty.      @return  True if the queue is empty, or false otherwise. */	public boolean isEmpty() {		// If the back space and the front entry point to the same spot, then the queue is empty.		return (isEmpty);	}	/** Removes all entries from this queue. */	public void clear() {				for (int i = 0; i < queue.length; i++) {			queue[i] = null;		}				frontEntry = 0;		backEntry = 0;		isEmpty = true;	}		/**	 * Returns an iterator that iterates over the stack's values. Removal is not supported.	 * (This functionality was added during the final!)	 * @return An iterator of type T that iterates over the stack's values	 */	public Iterator<T> getIterator() {		return new FixedArrayQueueIterator();	}		private class FixedArrayQueueIterator implements Iterator<T> {				// index is the index of the value we just gave.		private int index = -1;				@Override		public boolean hasNext() {			// TODO: Check this			return index != backEntry + 1;		}		@Override		public T next() {			if (!hasNext()) {				throw new NoSuchElementException();			}						// Because our values might wrap around, we wrap around too			index = (index + 1) % queue.length;			return queue[index];					}		@Override		public void remove() {			throw new UnsupportedOperationException();		}		}}